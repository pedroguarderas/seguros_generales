# Tarificación

## Prima
La prima es la cantidad de dinero que un individuo o entidad pagan por una póliza de seguro, la cual
está diseñada para cubrir ciertos riesgos personales o comerciales.

La determinación de las primas por parte del asegurador hace uso de la mutualización del riesgo y
diversificación, para así poder asumir la transferencia del riesgo por parte de sus asegurados. Así
por tanto, es deseable que cualquier método que se utilice para la estimación de primas, se 
satisfaga, algunas propiedades importantes.

Sin consideramos dos riesgos a cubrir $S_1$ y $S_2$, entonces la función que estima $\rho$ las primas 
sería aconsejable satisfaga las siguientes propiedades.

1. Si se decide cobrir por compleo dos riesgos $S_1$ y $S_2$ en un mismo producto, el valor de la 
prima deberá ser menor o igual al valor que se resultaría de cubrir cada uno de los riesgos con 
productos separados.
\begin{equation}
\rho( S_1 + S_2 ) \leq \rho( S_1 ) + \rho( S_2 )
\end{equation}

2. El asumir mayor riesgo debe tener como consecuencia el aumento de la prima
\begin{equation}
\rho( S_1 ) \leq \rho( S_1 + S_2 )
\end{equation}
Esta propiedad implica que al configurar un producto de seguro con mejor cobertura, se espera 
una prima de mayor costo.

3. Si el riesgo a cubrir está limitado, es decir $P( S \leq M ) = 1$, para un valor $M > 0$, 
entonces jamás la prima será superior a $M$
\begin{equation}
\rho( S ) \leq M
\end{equation}
Esto se traduce a que ningún asegurado estará interesado en adquirir una póliza para cubrir un 
riesgo por encima del valor total asegurado.


Es así que hay algunos principios para la estimación de primas, aquí citamos algunos de los más 
conocidos:

1. Prima neta, o prima pura de riesgo
\begin{equation}
  \rho( S ) = \mathbb{E}[S]
\end{equation}

2. Prima de riesgo con recargo sobre la esperanza matemática
\begin{equation}
  P = \rho( S ) = (1 + \rho) \mathbb{E}[S]
\end{equation}

3. Prima de riesgo con recargo sobre la varianza
\begin{equation}
  P = \rho( S ) = \mathbb{E}[S] + \rho \mathbb{V}[S]
\end{equation}

4. Prima de riesgo con recargo sobre la desviación
\begin{equation}
  P = \rho( S ) = \mathbb{E}[S] + \rho \sqrt{\mathbb{V}[S]}
\end{equation} 

5. Prima de riesgo con principio exponencial para $t > 0$
\begin{equation}
  P = \rho( S )
  = \frac{1}{2} \mathbb{E}\left[e^{tS}\right]
  = \frac{1}{2} M_N\big( \ln M_X( t ) \big)
\end{equation}

6. Prima de percentiles para un valor de confianza $\alpha \in [0,1]$ o prima de valor en riesgo 
$VaR_\alpha$
\begin{equation}
  P = \rho( S ) = VaR_\alpha( S ) =  F_S^{-1}( \alpha )
\end{equation}

7. Prima de valor en riesgo en la cola (Tail Value at Risk) $TVaR_\alpha$. Es el promedio uniforme
de todos los valores en riesgo $VaR_u$, con $u \geq \alpha$.
\begin{equation}
P = \rho( S ) = TVaR_\alpha( S ) = \frac{1}{1-\alpha} \int\limits_{\alpha}^1 VaR_u( S )\ du
\end{equation}


$X_i \rightsquigarrow Gamma( \alpha_i, \theta )$, para $i \in \{1,\ldots,n\}$, 
$S \rightsquigarrow Gamma\left( \sum\limits_{i=1}^n \alpha_i \right)$
```{r l5c1}
n <- 1000
a <- runif( n, 5, 10 )
A <- sum( a )
theta <- 4
EX <- a * theta
VX <- a * theta^2
ES <- sum( EX )
VS <- sum( VX )
SDS <- sqrt( VS )

m <- 1e5
S <- rgamma( m, shape = A, scale = theta )

alpha <- 0.95
P <- ES
P <- mean( S )

P_avg <- ( 1 + alpha ) * ES
P_avg <- ( 1 + alpha ) * mean( S )

P_var <- ES + alpha * VS
P_var <- mean( S ) + alpha * var( S )

P_sde <- ES + alpha * SDS
P_sde <- mean( S ) + alpha * sd( S )

VaRS <- qgamma( alpha, shape = A, scale = theta )
P_VaR <- VaRS
P_VaR <- quantile( S, probs = alpha )

P_TVaR <- ( 1 / ( 1 - alpha ) ) * ( A * theta ) * ( 1 - pgamma( VaRS, shape = A + 1, scale = theta ) )
P_TVaR <- ( 1 / ( 1 - alpha ) ) * integrate( f = function( u ) qgamma( u, shape = A, scale = theta ), alpha, 1 )$value
P_TVaR <- mean( sapply( runif( m, alpha, 1 ), FUN = function( k ) qgamma( k, shape = A, scale = theta ) ) )
I <- as.numeric( S > VaRS )
P_TVaR <- mean( S * I ) / mean( I )
```

```{r l5c2}
alph <- 0.01
e <- unlist( lapply( seq( 1, 6, 1 ), FUN = function( n ) seq( 9, 1, -0.2 ) * 10^{-n} ) )
n <- log( 2 / alph ) / e^2
plot( e, n, type = 'l', xlim = c( 0, 0.00001 ) )
dt <- data.table( e, n )
cat( paste( paste0( formatC( e, digits = 10, format = 'f' ), ', ', formatC( n, digits = 30, format = 'f' ) ), collapse = '\n' ) )

d <- n * 8 / 1024^2
```

```{r l5c3}
n <- 1e3
S <- rgamma( n, shape = A, scale = theta )
smin <- qgamma( 0.001, shape = A, scale = theta )
smax <- qgamma( 0.999, shape = A, scale = theta )
s <- seq( smin, smax, length.out = 1000 )
Fns <- ecdf( S )( s )
Fs <- pgamma( s, shape = A, scale = theta )

alph <- 0.02
er <- sqrt( log( 2 / alph ) / ( 2 * n ) )
abs( Fs - Fns ) > er 

plot( s, Fs, type = 'l', ylim = c( -er, 1 + er ) )
points( s, Fns - er, col = 'red', type = 'l' )
points( s, Fns + er, col = 'red', type = 'l' )

hist( pgamma( S, shape = A, scale = theta ), breaks = 5 )
```

<!------------------------------------------------------------------------------------------------->
## Segmentación

En muchas ocasiones es necesario tener en cuenta algunas características asociadas al riesgo 
de asegurado, de tal forma que la prima sea lo más eficiente y adecuado según el riesgo cubierto y
las características del mismo. La idea de segmentar la población es obtener grupos homogéneos 
con riesgos similares.

<!------------------------------------------------------------------------------------------------->
## Medidas de riesgo

::: {.definition #spv name="Medida de riesgo coherente"}
Una **medida de riesgo coeherente** es una función $\zeta: \mathbb{R} \longrightarrow \mathbb{R}$, 
que satisface la siguientes propiedades:

1. **Homogenidad positiva**, para cualquier $a > 0$
\begin{equation}
\zeta( a X ) = a \zeta( X )
\end{equation}

2. **Invarianza ante las traslaciones**, para cualquier $a > 0$
\begin{equation}
\zeta( \alpha X + a ) = \zeta( \alpha X ) + a
\end{equation}

3. **Monotonicidad**, Si $X \leq Y$
\begin{equation}
\zeta( X ) \leq \zeta( Y )
\end{equation}

4. **Sub-aditividad**
\begin{equation}
\zeta( X + Y ) \leq \zeta( X ) + \zeta( Y )
\end{equation}
:::

\begin{equation}
VaR_{\alpha}( X ) = F_X^{-1}( \alpha )
\end{equation}

\begin{equation}
TVaR_{\alpha}( X ) = \frac{1}{1-\alpha} \int\limits_{\alpha}^1 VaR_u( X )\ du
\end{equation}

```{r l5c4}
u <- 4
s <- 0.5
n <- 1e4
X <- rlnorm( n, meanlog = u, sdlog = s )
k <- seq( 0, 1, 0.2 ) 
VaRX <- quantile( X, probs = k, names = FALSE )
TVaRX <- sapply( 
  1:length( VaRX ), 
  FUN = function( i ) ifelse( k[ i ] < 1, ( 1 / ( 1 - k[ i ] ) ) * mean( X * ( X > VaRX[ i ] ) ), max( X ) ) )

hist( X, breaks = 100, xlim = c( 0, 1.1 * max( X ) ) )
abline( v = VaRX, col = 'red' )

hist( X, breaks = 100, xlim = c( 0, 1.1 * max( X ) ) )
abline( v = TVaRX, col = 'blue' )
```

```{r l5c5}
plot( k, VaRX, ylim = c( 0, 1e3 ) )
points( k, TVaRX, col = 'red' )
```


<!------------------------------------------------------------------------------------------------->
## Deducibles

El principal objetivo de los deducibles, es el reducir los costos de atención de los reclamos 
usualmente mediante la exclusión de siniestros usualmente numerosos debidos a reclamos pequeños.
En otras ocasiones, los deducibles están diseñados para incentivar al asegurado para evitar 
y prevenir siniestros por cierto monto límite.

1. Prevención de la pérdida - as the compensation is reduced by a deductible the retention of the 
insured is positive; This makes out a good case for avoiding the loss; 

2. Reducción de la pérdida - the fact a deductible puts the policyholder at risk of obtaining 
only partial compensation provides an economic incentive to reduce the extend of the damage; 

3. Evitar pequeñas pérdidas - where administration costs are dominant for small losses, the 
administration costs will often exceed the loss itself, and hence the insurance company would want 
the policyholder to pay it himself; 

4. Reducción de la prima - premium reduction can be an important aspect for the policyholders, 
they may prefer to take a higher deductible to get a lower premium.


```{r l5c6}
n <- 1e5
l <- 3
dat <- data.table( id = 1:n, k = rpois( n, lambda = l )  )
datf <- dat[ , list( fk = .N ), by = k ]
setorder( datf, k )
datf[ , fks := shift( fk, n = 1 ) ]
datf[ , gk := k * fk / fks ]
datf <- datf[ !is.na( gk ) ]
plot( datf$k, datf$gk )
```

```{r l5c7}
dflm <- lm( formula = gk ~ k, data = datf, method = 'qr' )
a <- coef( dflm )[ 2 ]
b <- coef( dflm )[ 1 ]
p0 <- exp( -b )
k <- seq( 1, 100, 1 )
p <- p0 * cumprod( c( 1, a + b / k ) )
sum( p )
k <- seq( 0, 100, 1 )
sum( dpois( k, lambda = l ) )
EN <- sum( k * p )
```

```{r l5c8}
D <- function( x, d ) return( max( x - d, 0 ) )
d <- 100
u <- 6
s <- 0.3
n <- 1e3
X <- rlnorm( n, meanlog = u, sdlog = s )
DX <- sapply( X, FUN = D, d )
x <- seq( 0, 1e3, length.out = 500 )
FXe <- ecdf( X )
FDXe <- ecdf( DX )
Fx <- sapply( x, FUN = function( x ) FXe( x ) )
FDx <- sapply( x, FUN = function( x ) FDXe( x ) )
plot( x, Fx, type = 's' )
points( x, FDx, type = 's', col = 'blue' )
```


```{r l5c9}
D <- function( x, M ) return( min( x, M ) )
M <- 600
u <- 6
s <- 0.3
n <- 1e4
X <- rlnorm( n, meanlog = u, sdlog = s )
DX <- sapply( X, FUN = D, M )
x <- seq( 0, 1e3, length.out = 500 )
FXe <- ecdf( X )
FDXe <- ecdf( DX )
Fx <- sapply( x, FUN = function( x ) FXe( x ) )
FDx <- sapply( x, FUN = function( x ) FDXe( x ) )
plot( x, Fx, type = 's' )
points( x, FDx, type = 's', col = 'blue' )
```
